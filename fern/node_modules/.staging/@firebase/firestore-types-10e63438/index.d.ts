/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { FirebaseApp, FirebaseNamespace } from '@firebase/app-types';

/**
 * Document data (for use with `DocumentReference.set()`) consists of fields
 * mapped to values.
 */
export type DocumentData = { [field: string]: any };

/**
 * Update data (for use with `DocumentReference.update()`) consists of field
 * paths (e.g. 'foo' or 'foo.baz') mapped to values. Fields that contain dots
 * reference nested fields within the document.
 */
export type UpdateData = { [fieldPath: string]: any };

/**
 * Constant used to indicate the LRU garbage collection should be disabled.
 * Set this value as the `cacheSizeBytes` on the settings passed to the
 * `Firestore` instance.
 */
export const CACHE_SIZE_UNLIMITED: number;

/** Settings used to configure a `Firestore` instance. */
export interface Settings {
  /** The hostname to connect to. */
  host?: string;
  /** Whether to use SSL when connecting. */
  ssl?: boolean;

  /**
   * Specifies whether to use `Timestamp` objects for timestamp fields in
   * `DocumentSnapshot`s. This is enabled by default and should not be
   * disabled.
   *
   * Previously, Firestore returned timestamp fields as `Date` but `Date` only
   * supports millisecond precision, which leads to truncation and causes
   * unexpected behavior when using a timestamp from a snapshot as a part of a
   * subsequent query.
   *
   * So now Firestore returns `Timestamp` values instead of `Date`, avoiding
   * this kind of problem.
   *
   * To opt into the old behavior of returning `Date` objects, you can
   * temporarily set `timestampsInSnapshots` to false.
   *
   * @deprecated This setting will be removed in a future release. You should
   * update your code to expect `Timestamp` objects and stop using the
   * `timestampsInSnapshots` setting.
   */
  timestampsInSnapshots?: boolean;

  /**
   * An approximate cache size threshold for the on-disk data. If the cache grows beyond this
   * size, Firestore will start removing data that hasn't been recently used. The size is not a
   * guarantee that the cache will stay below that size, only that if the cache exceeds the given
   * size, cleanup will be attempted.
   *
   * The default value is 40 MB. The threshold must be set to at least 1 MB, and can be set to
   * CACHE_SIZE_UNLIMITED to disable garbage collection.
   */
  cacheSizeBytes?: number;

  /**
   * Forces the SDKâ€™s underlying network transport (WebChannel) to use
   * long-polling. Each response from the backend will be closed immediately
   * after the backend sends data (by default responses are kept open in case
   * the backend has more data to send). This avoids incompatibility issues
   * with certain proxies, antivirus software, etc. that incorrectly buffer
   * traffic indefinitely. Use of this option will cause some performance
   * degradation though.
   *
   * This setting may be removed in a future release. If you find yourself
   * using it to work around a specific network reliability issue, please tell
   * us about it in https://github.com/firebase/firebase-js-sdk/issues/1674.
   *
   * @webonly
   */
  experimentalForceLongPolling?: boolean;
}

/**
 * Settings that can be passed to Firestore.enablePersistence() to configure
 * Firestore persistence.
 */
export interface PersistenceSettings {
  /**
   * Whether to synchronize the in-memory state of multiple tabs. Setting this
   * to 'true' in all open tabs enables shared access to local persistence,
   * shared execution of queries and latency-compensated local document updates
   * across all connected instances.
   *
   * To enable this mode, `synchronizeTabs:true` needs to be set globally in all
   * active tabs. If omitted or set to 'false', `enablePersistence()` will fail
   * in all but the first tab.
   */
  synchronizeTabs?: boolean;

  /**
   * Whether to synchronize the in-memory state of multiple tabs. Setting this
   * to 'true' in all open tabs enables shared access to local persistence,
   * shared execution of queries and latency-compensated local document updates
   * across all connected instances.
   *
   * @deprecated This setting is deprecated. To enabled synchronization between
   * multiple tabs, please use `synchronizeTabs: true` instead.
   */
  experimentalTabSynchronization?: boolean;
}

export type LogLevel = 'debug' | 'error' | 'silent';

export function setLogLevel(logLevel: LogLevel): void;

/**
 * `Firestore` represents a Firestore Database and is the entry point for all
 * Firestore operations.
 */
export class FirebaseFirestore {
  private constructor();
  /**
   * Specifies custom settings to be used to configure the `Firestore`
   * instance. Must be set before invoking any other methods.
   *
   * @param settings The settings to use.
   */
  settings(settings: Settings): void;

  /**
   * Attempts to enable persistent storage, if possible.
   *
   * Must be called before any other methods (other than settings() and
   * clearPersistence()).
   *
   * If this fails, enablePersistence() will reject the promise it returns.
   * Note that even after this failure, the firestore instance will remain
   * usable, however offline persistence will be disabled.
   *
   * There are several reasons why this can fail, which can be identified by
   * the `code` on the error.
   *
   *   * failed-precondition: The app is already open in another browser tab.
   *   * unimplemented: The browser is incompatible with the offline
   *     persistence implementation.
   *
   * @param settings Optional settings object to configure persistence.
   * @return A promise that represents successfully enabling persistent
   * storage.
   */
  enablePersistence(settings?: PersistenceSettings): Promise<void>;

  /**
   * Gets a `CollectionReference` instance that refers to the collection at
   * the specified path.
   *
   * @param collectionPath A slash-separated path to a collection.
   * @return The `CollectionReference` instance.
   */
  collection(collectionPath: string): CollectionReference;

  /**
   * Gets a `DocumentReference` instance that refers to the document at the
   * specified path.
   *
   * @param documentPath A slash-separated path to a document.
   * @return The `DocumentReference` instance.
   */
  doc(documentPath: string): DocumentReference;

  /**
   * Creates and returns a new Query that includes all documents in the
   * database that are contained in a collection or subcollection with the
   * given collectionId.
   *
   * @param collectionId Identifies the collections to query over. Every
   * collection or subcollection with this ID as the last segment of its path
   * will be included. Cannot contain a slash.
   * @return The created Query.
   */
  collectionGroup(collectionId: string): Query;

  /**
   * Executes the given updateFunction and then attempts to commit the
   * changes applied within the transaction. If any document read within the
   * transaction has changed, the updateFunction will be retried. If it fails
   * to commit after 5 attempts, the transaction will fail.
   *
   * The maximum number of writes allowed in a single transaction is 500, but
   * note that each usage of `FieldValue.serverTimestamp()`,
   * `FieldValue.arrayUnion()`, `FieldValue.arrayRemove()`, or
   * `FieldValue.increment()` inside a transaction counts as an additional write.
   *
   * @param updateFunction The function to execute within the transaction
   * context.
   *
   * @return If the transaction completed successfully or was explicitly
   * aborted (by the updateFunction returning a failed Promise), the Promise
   * returned by the updateFunction will be returned here. Else if the
   * transaction failed, a rejected Promise with the corresponding failure
   * error will be returned.
   */
  runTransaction<T>(
    updateFunction: (transaction: Transaction) => Promise<T>
  ): Promise<T>;

  /**
   *  Creates a write batch, used for performing multiple writes as a single
   * atomic operation. The maximum number of writes allowed in a single WriteBatch
   * is 500, but note that each usage of `FieldValue.serverTimestamp()`,
   * `FieldValue.arrayUnion()`, `FieldValue.arrayRemove()`, or
   * `FieldValue.increment()` inside a WriteBatch counts as an additional write.
   *
   * @return
   *   A `WriteBatch` that can be used to atomically execute multiple writes.
   */
  batch(): WriteBatch;

  /**
   * The `FirebaseApp` associated with this `Firestore` instance.
   */
  app: any;

  /**
   * Clears the persistent storage. This includes pending writes and cached
   * documents.
   *
   * Must be called while the firestore instance is not started (after the app
   * is shutdown or when the app is first initialized). On startup, this
   * method must be called before other methods (other than settings()). If
   * the firestore instance is still running, the promise will be rejected
   * with the error code of `failed-precondition`.
   *
   * Note: clearPersistence() is primarily intended to help write reliable
   * tests that use Cloud Firestore. It uses an efficient mechanism for
   * dropping existing data but does not attempt to securely overwrite or
   * otherwise make cached data unrecoverable. For applications that are
   * sensitive to the disclosure of cached data in between user sessions, we
   * strongly recommend not enabling persistence at all.
   *
   * @return A promise that is resolved when the persistent storage is
   * cleared. Otherwise, the promise is rejected with an error.
   */
  clearPersistence(): Promise<void>;

  /**
   * Re-enables use of the network for this Firestore instance after a prior
   * call to disableNetwork().
   *
   * @return A promise that is resolved once the network has been enabled.
   */
  enableNetwork(): Promise<void>;

  /**
   * Disables network usage for this instance. It can be re-enabled via
   * enableNetwork(). While the network is disabled, any snapshot listeners or
   * get() calls will return results from cache, and any write operations will
   * be queued until the network is restored.
   *
   * @return A promise that is resolved once the network has been disabled.
   */
  disableNetwork(): Promise<void>;

  /**
   * Waits until all currently pending writes for the active user have been acknowledged by the
   * backend.
   *
   * The returned Promise resolves immediately if there are no outstanding writes. Otherwise, the
   * Promise waits for all previously issued writes (including those written in a previous app
   * session), but it does not wait for writes that were added after the method is called. If you
   * want to wait for additional writes, call `waitForPendingWrites()` again.
   *
   * Any outstanding `waitForPendingWrites()` Promises are rejected during user changes.
   *
   * @return A Promise which resolves when all currently pending writes have been
   * acknowledged by the backend.
   */
  waitForPendingWrites(): Promise<void>;

  /**
   * Attaches a listener for a snapshots-in-sync event. The snapshots-in-sync
   * event indicates that all listeners affected by a given change have fired,
   * even if a single server-generated change affects multiple listeners.
   *
   * NOTE: The snapshots-in-sync event only indicates that listeners are in sync
   * with each other, but does not relate to whether those snapshots are in sync
   * with the server. Use SnapshotMetadata in the individual listeners to
   * determine if a snapshot is from the cache or the server.
   *
   * @param observer A single object containing `next` and `error` callbacks.
   * @return An unsubscribe function that can be called to cancel the snapshot
   * listener.
   */
  onSnapshotsInSync(observer: {
    next?